from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!

def convert_to_table( erd ):
    relationship_list = erd.relationships
    entity_sets = erd.entity_sets
   
    e_tables = entity_tables(entity_sets)
    
    if len(relationship_list) == 0:
        database = Database(e_tables)
        return database

    e_dict = {}

    for r in relationship_list:
        r_name = r.name
        r_attributes = [r.attributes]
        r_primary = [r.primary_key]
        many_list = []
        one_list = []
        parents = 0
        support = []
        for e in entity_sets:
            connections = e.connections
            support_relation = e.supporting_relations
            e_parents = e.parents

            if len(e_parents) != 0:
                for p in e_parents:
                    parents += 1

            if len(support_relation) != 0:
                for sup in support_relation:
                    if sup == r_name:
                        support.append(e)
                    
            for c in connections:
                c_name = c[0]
                c_multiplicity = c[1]
                if c_name == r_name:
                    if c_multiplicity == Multiplicity.MANY:
                        many_list.append(e)
                    elif c_multiplicity == Multiplicity.ONE:
                        one_list.append(e)

        m_list = [many_list, one_list, r.attributes, r.primary_key, support, parents]

                
        e_dict[r_name] = m_list


    m_tables = iterate_dict(e_dict, e_tables)
    
    
    database = Database(m_tables)


    return database
    





    # return sample_db

def entity_tables(entity_sets):
    tables = []
    foreign_key = set()

    for entity in entity_sets:
        name = entity.name
        attribute = entity.attributes
        primary = entity.primary_key
        connections = entity.connections
        parents = entity.parents
        supporting = entity.supporting_relations

        if len(parents) != 0:
            for p in parents:
                for t in tables:
                    if t.name == p:
                        pri = t.primary_key
                        p_name = t.name
                        for prime in pri:
                            attribute.append(prime)
                            primary.append(prime)
                            foreign_applied = (prime, )
                            foreign_referenced = (prime, )
                            f = (foreign_applied, p_name, foreign_referenced)
                            foreign_key.add(f)
        
        

        attributes = set(attribute)
        primary_keys = set(primary)

        
        T = Table(name, attributes, primary_keys, foreign_key)
        tables.append(T)
        foreign_key = set()
    
    return tables


def relationship_tables (mult_list, name, one_many):
    table = []
    
    foreign_set = set()
    fk = []
    attributes = set(mult_list[2])
    primary = set(mult_list[3])
    
    if one_many == False:
        for e in mult_list[0]:
            pri = e.primary_key
            e_name = e.name

            for pr in pri:
                attributes.add(pr)
                primary.add(pr)
            

            if len(pri) >= 1:
                foreign_applied = tuple(pri)
                foreign_referenced = tuple(pri)
                f = tuple([foreign_applied, e_name, foreign_referenced])
                foreign_set.add(f)


            else:
                foreign_applied = (pr,)
                foreign_referenced = (pr,)
                f = (foreign_applied, e_name , foreign_referenced)
                foreign_set.add(f)
            
    
    if one_many == True:
        for e in mult_list[0]:
            pri = e.primary_key
            e_name = e.name
            for pr in pri:
                attributes.add(pr)
                primary.add(pr)
                foreign_applied = (pr,)
                foreign_referenced = (pr,)
                f = (foreign_applied, e_name , foreign_referenced)
                foreign_set.add(f)

        for e in mult_list[1]:
            pri = e.primary_key
            e_name = e.name
            for pr in pri:
                attributes.add(pr)
                foreign_applied = (pr,)
                foreign_referenced = (pr,)
                f = (foreign_applied, e_name , foreign_referenced)
                foreign_set.add(f)
            
    
    T = Table(name, attributes, primary, foreign_set)
    
    return T


def one_many(mult_list, Relation_attribute):
    
    foreign_set = set()
    
    for e in mult_list[0]:
        pri = e.primary_key
        e_name = e.name
        attributes = e.attributes

        for ent in mult_list[1]:
            prime = ent.primary_key
            one_name = ent.name

            for pr in prime:
                attributes.append(pr)

            
            foreign_applied = tuple(prime)
            foreign_referenced = tuple(prime)
            f = tuple([foreign_applied, one_name, foreign_referenced])
            foreign_set.add(f)

        
        primary_set = set(pri)
        if Relation_attribute == False:
            attributes_set = set(attributes)
            T = Table(e_name, attributes_set, primary_set, foreign_set)
        elif Relation_attribute == True:
            r_attributes = mult_list[2]
            for r in r_attributes:
                attributes.append(r)

            attribute_set = set(attributes)
            T = Table(e_name, attribute_set, primary_set, foreign_set)
        

    return T





def iterate_dict(e_dict, e_tables):

    tables = []

    for dic in e_dict:
        name = dic
        m_list = e_dict[dic]
        
        if len(m_list[1]) == 0 and len(m_list[0]) > 1:
            T = relationship_tables(m_list, name, False)
            e_tables.append(T)

            

        elif len(m_list[0]) == len(m_list[1]) and len(m_list[3])!= 0:
            T = relationship_tables(m_list, name, True)
            e_tables.append(T)
            
        elif len(m_list[0]) == len(m_list[1]) and len(m_list[2]) != 0:
            T = one_many(m_list, True)

            t_name = T.name
            for e_t in e_tables:
                if e_t.name == t_name:
                    i = e_tables.index(e_t)
                    e_tables[i] = T

        elif len(m_list[0]) == len(m_list[1]):
            T = one_many(m_list, False)

            t_name = T.name
            for e_t in e_tables:
                if e_t.name == t_name:
                    i = e_tables.index(e_t)
                    e_tables[i] = T
    
            

        elif len(m_list[1]) == 1 and len(m_list[3]) == 0 and m_list[5] > 0:
            same_name = []
            for table in e_tables:
                fk = table.foreign_keys
                fk = list(fk)
                if len(fk) >= 1:
                    temp_fk = fk[0]
                    temp_name = temp_fk[1]
                if len(fk) >=2:
                    for foreign in fk [1::]:
                        fk_name = foreign[1]
                       
                        if temp_name == fk_name:
                            same_name.append(fk[0])
                            same_name.append(fk[1])
                            new_fk = combine_fk(same_name)
                            
                            table.foreign_keys = new_fk

            
            return e_tables
        
        elif len(m_list[4]) != 0 and len(m_list[1]) == 1:
            tables = support(m_list, e_tables)
            return tables

    return e_tables



def support(m_list, e_tables):
    support_e = m_list[1]
    supported = m_list[4]
    foreign_keys = set()
    for s in support_e:
        s_name = s.name
        s_primary = s.primary_key
        for e in supported:
            e_name = e.name
            for e_table in e_tables:
                if e_table.name == e_name:
                    index = e_tables.index(e_table)
                    e_attributes = e.attributes
                    e_prime = e.primary_key
                    for prime in s_primary:
                        e_attributes.append(prime)
                        e_prime.append(prime)
                        foreign_applied = (prime, )
                        foreign_referenced = (prime, )
                        f = (foreign_applied, s_name, foreign_referenced)
                        
                        foreign_keys.add(f)
                        
                        
                        T = Table(e_name, set(e_attributes), set(e_prime), foreign_keys)
                        e_tables[index] = T

    return e_tables                    

def combine_fk(foreign_keys):
    fk_list = []
    foreign_applied = []
    foreign_referenced = []
    fk_name = ""

    for fk in foreign_keys:
        fk_name = fk[1]
        foreign_applied.append(fk[0])
        foreign_referenced.append(fk[2])
    
    foreign_applied = tuple(foreign_applied)
    foreign_referenced = tuple(foreign_referenced)
    f = tuple([foreign_applied, fk_name, foreign_referenced])
    return f
    

